# ✍️ 작성자
김지수

---

# ❓ 질문
인덱스를 사용하지 않고 데이터 조회 성능을 개선할 수 있는 방법을 구체적인 사례와 함께 설명해주세요.

---

# 💬 답변 요약
다음과 같은 전략을 사용하면 인덱스 없이도 조회 성능을 개선할 수 있다.

- 집계 쿼리를 조회 시점에 실행하지 않고 미리 계산하여 저장하기
- 페이지 기준 목록 조회 대신 ID 기준 목록 조회 방식 사용하기
- 조회 범위를 시간 기준으로 제한하기
- 전체 개수 세지 않기
- 오래된 데이터 삭제하거나 분리 보관하기
- DB 장비 확장하기
- 별도 캐시 서버 구성하기

---

# 🧠 핵심 키워드
반정규화, 중복 칼럼, 오프셋, 서브 쿼리 제거, 사전 집계

---

# 🔥 상세 설명

## 📊 집계 쿼리를 조회 시점에 실행하지 않고 미리 집계하기

### ⚠️ 문제 상황
게시글 목록에서 각 게시글의 댓글 수와 좋아요 수를 함께 보여줘야 하는 요구 사항이 있을 수 있다.  
(단, 동일한 사용자가 같은 게시글에 댓글을 여러 개 작성할 수 없다고 가정한다.)  
이 요구 사항을 충족하기 위해 게시글 목록 조회 쿼리의 `select`절에 `서브 쿼리`를 작성해보자.

```sql
SELECT p.id, p.title,
    
    -- 댓글 단 회원 수 (중복 제거)
    (
        SELECT COUNT(DISTINCT c.member_id)
        FROM Comment c
        WHERE c.post_id = p.id
    ) AS commenter_count,

    -- 좋아요 누른 회원 수 
    (
        SELECT COUNT(l.member_id)
        FROM Post_Like l
        WHERE l.post_id = p.id
    ) AS liker_count

FROM Post p;
```  
<br>
위 쿼리는 논리적으로 문제가 없다. 그러나 아래와 같은 상황에서 성능에 문제가 발생한다.

```text
- 게시글 수: 30개
- 각 게시글마다 댓글을 작성한 평균 회원 수: 10만 명
- 각 게시글마다 '좋아요'를 누른 평균 회원 수: 1만 명
```

| 쿼리 종류              | 횟수  | 설명             |
|:-------------------|:----|:---------------|
| SELECT * FROM Post | 1회  | 게시글 목록 가져오기    |
| 댓글 수 서브 쿼리         | 30회 | 각 게시글마다 1번씩 실행 |
| 좋아요 수 서브 쿼리        | 30회 | 각 게시글마다 1번씩 실행 |
|                    | 61회 | 합계: 너무 느리다! 🐢 |

### ✅ 해결 방법
`count`나 `sum`과 같이 집계 쿼리를 조회 시점에 실행하면 성능 문제가 발생할 수 있다.  
이러한 문제를 제거하려면 집계 데이터를 미리 계산해서 `별도 칼럼에 저장`하면 된다.  
위의 예시에서는 게시글 테이블에 댓글 수와 '좋아요' 수를 저장할 칼럼을 추가하고, 댓글/'좋아요'를 추가/삭제할 때마다 값을 계산하면 된다.  

만약 댓글을 작성했다면, 아래와 같이 구현한다.
```sql
-- 1. 댓글 추가
INSERT INTO Comment VALUES (...);

-- 2. 댓글 수 증가
UPDATE Post
SET comment_cnt = comment_cnt + 1
WHERE id = :postId;
```

<br>
만약 '좋아요'를 취소했다면, 아래와 같이 구현한다.

```sql
-- 1. 좋아요 삭제
DELETE FROM Post_Like
WHERE post_id = :postId
  AND member_id = :memberId;

-- 2. 좋아요 수 감소 
UPDATE Post
SET like_cnt = like_cnt - 1
WHERE id = :postId
  AND like_cnt > 0; --- 음수 방지
```

<br>

이제 게시글 목록을 조회할 때 댓글 수와 '좋아요' 수를 집계하기 위한 서브 쿼리를 작성하지 않아도 된다.  
서브 쿼리 시간만큼 쿼리 실행 시간이 감소하기 때문에, 조회 성능이 향상된다.

```sql
SELECT p.id, p.title, comment_cnt, like_cnt --- 서브 쿼리 삭제!
FROM Post p;
```

> ❓ 반정규화해도 괜찮을까?  
> 게시글 테이블에 `comment_cnt`, `like_cnt` 컬럼을 추가하는 것은 데이터의 중복을 의미한다.  
> 댓글 수와 좋아요 수는 각 테이블에서 직접 계산할 수 있기 때문이다.  
> 이러한 방식은 `comment_cnt` 값과 실제 댓글 개수가 일치하지 않을 수 있다는 점에서 `데이터 무결성`을 해칠 위험이 있다.  
> 하지만 위와 같은 사례에서는 약간의 불일치를 감수하더라도 별도의 컬럼을 두는 편이 효율적일 수 있다.  
> 게시글 목록을 조회하는 사용자 입장에서는 그리 중요한 문제가 아니기 때문이다.  
> 게다가, 정확한 수치가 필요한 시점(예: 관리자 통계, 보고서 등)에는 실제 테이블에서 얼마든지 집계할 수 있다.

## 🆔 페이지 기준 목록 조회 대신 ID 기준 목록 조회 방식 사용하기

### ⚠️ 문제 상황
게시글 데이터가 10만 개일 때, 한 페이지에 10개의 게시글을 보여주면 전체 페이지 개수는 1만 개가 된다.  
우리는 마지막 1만 번째 페이지에 해당하는 게시글들을 조회하기 위해 아래와 같은 쿼리를 이용할 수 있다.

```sql
SELECT *
FROM Post
ORDER BY id DESC
LIMIT 10 OFFSET 99990;
```

<br>

위 쿼리를 실행할 때 DB는 99,991번째 아이디가 어떤 값인지 알기 위해 `OFFSET`만큼의 데이터를 세야 한다.  
만약 인덱스에 포함되지 않은 칼럼이 `where`절에 포함된다면 쿼리 실행 시간은 더 늘어난다.

### ✅ 해결 방법
지정한 `OFFSET`만큼 데이터를 세는 시간을 줄이기 위해서는 `특정 아이디를 기준으로 조회`하면 된다.  
예를 들어 데이터의 아이디 칼럼값이 아래와 같이 분포돼있다고 가정해보자.  

```text
10000 <- 1번째 데이터
...
9985 <- 10번째 데이터
9984 <- 11번째 데이터
...
```

<br>

처음 데이터 10개를 읽어오는 쿼리는 아래와 같다.  
이 쿼리로 조회한 마지막 데이터의 아이디는 9985가 될 것이다.

```sql
SELECT *
FROM Post
ORDER BY id DESC
LIMIT 10;
```

<br>

다음 데이터 10개를 읽어올 때는 직전에 읽은 마지막 데이터의 아이디(9985)를 사용하면 된다.  
아이디는 인덱스이므로 9985보다 작은 아이디 값인 9984를 바로 찾을 수 있다.  
다음에 읽어올 데이터의 존재 여부를 응답해야 한다면, `LIMIT 11`으로 1개 더 읽은 뒤 조회 결과가 11개인지 확인하면 된다.

```sql
SELECT *
FROM Post
WHERE id < 9985
ORDER BY id DESC
LIMIT 10;
```

## 📝 요약
| 문제 상황                      | 해결 방법             |
|----------------------------|-------------------|
| 조회 시 집계 쿼리로 인해 성능이 느림      | 집계 결과를 별도 칼럼에 저장함 |
| 페이징 시 `OFFSET`만큼 데이터를 세야 함 | 아이디 기준으로 목록을 조회함  |

---

# 🔗 참고 자료
- 최범균, 주니어 백엔드 개발자가 반드시 알아야 할 실무 지식, 한빛미디어(2025)